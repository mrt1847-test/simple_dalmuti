<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>달무티 게임</title>
  <style>
    html, body {
      height: auto;
      min-height: 100vh;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: auto;
      min-height: 100vh;
      background: #f5f5dc;
      overflow-y: auto;
    }
    #mainWrap {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
      width: 100%;
    }
    #gameArea {
      min-width: 420px;
      max-width: 90vw;
    }
    #chatWrap {
      width: 380px;
      min-width: 300px;
      margin-left: 3em;
      margin-right: 2vw;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 1px 8px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      height: 540px;
    }
    #chatMessages { flex: 1; overflow-y: auto; padding: 1em; font-size: 1em; display: flex; flex-direction: column; }
    #chatInputWrap { display: flex; border-top: 1px solid #eee; }
    #chatInput { flex: 1 1 auto; min-width: 0; border: none; padding: 0.7em; font-size: 1em; border-radius: 0 0 0 10px; }
    #chatSend { width: 56px; border: none; background: #8bc34a; color: #fff; font-size: 1em; border-radius: 0 0 10px 0; cursor: pointer; }
    #chatSend:hover { background: #689f38; }

    /* 모바일 대응 */
    @media (max-width: 768px) {
      body { height: auto; min-height: 100vh; padding: 10px; }
      #mainWrap { flex-direction: column; align-items: center; flex-wrap: nowrap; padding-bottom: 33vh; }
      #gameArea { min-width: auto; width: 100%; max-width: 400px; }
      
      /* 게임 나가기 버튼 모바일 최적화 */
      #leaveGameBtn {
        padding: 10px 16px !important;
        font-size: 16px !important;
        min-height: 44px !important;
        background: #e57373 !important;
        border-radius: 8px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
      }
      
      /* 도움말 버튼 모바일 최적화 */
      #helpBtn {
        padding: 10px 16px !important;
        font-size: 16px !important;
        min-height: 44px !important;
      }
      
      #chatWrap {
        display: flex !important;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100vw;
        height: 33vh;
        min-height: 220px;
        max-height: 60vh;
        background: #fff;
        z-index: 2100;
        box-shadow: 0 -2px 16px rgba(0,0,0,0.18);
        border-radius: 16px 16px 0 0;
        flex-direction: column;
        justify-content: flex-end;
        transition: none;
        margin: 0;
      }
      
      /* 타이틀과 원탁 사이 간격 조정 */
      h1 { margin-bottom: 1.5em !important; }
      
      /* 턴 정보와 원탁 사이 간격 조정 */
      #gameContent > div:nth-child(2) { margin-top: 3.5em !important; }
      
      /* 플레이어 카드 폰트 크기 조정 */
      .player-card div { font-size: 0.8em !important; }
      
      /* 카드 크기 조정 */
      .cardBtn > div { width: 60px !important; height: 90px !important; font-size: 1.5em !important; }
      
      /* 핸드 카드 영역 최적화 - 8장 이상일 때 두 줄로 */
      #handArea { 
        flex-wrap: wrap !important; 
        justify-content: center !important; 
        gap: 5px !important;
        max-width: 400px !important;
      }
      
      /* 필드 카드 크기 조정 */
      #gameContent div[style*="width:80px;height:130px"] { width: 60px !important; height: 90px !important; }
      #helpModal > div {
        max-width: 95vw !important;
        width: 95vw !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
        box-sizing: border-box;
      }
      /* 모바일용 플로팅 버튼, 모바일 전용 채팅창 숨김 */
      #mobileChatBtn, #mobileChatWrap { display: none !important; }
    }

    /* 작은 모바일 대응 */
    @media (max-width: 480px) {
      #gameArea { max-width: 100%; }
      #chatWrap { max-width: 100%; }
      
      /* 타이틀과 원탁 사이 간격 더 조정 */
      h1 { margin-bottom: 1em !important; }
      
      /* 턴 정보와 원탁 사이 간격 더 조정 */
      #gameContent > div:nth-child(2) { margin-top: 3.5em !important; }
      
      /* 플레이어 카드 폰트 크기 더 작게 */
      .player-card div { font-size: 0.7em !important; }
      
      /* 카드 더 작게 */
      .cardBtn > div { width: 50px !important; height: 75px !important; font-size: 1.2em !important; }
      
      /* 핸드 카드 영역 더 작은 화면에서 최적화 */

      
      /* 필드 카드 더 작게 */
      #gameContent div[style*="width:80px;height:130px"] { width: 50px !important; height: 75px !important; }
      #helpModal > div {
        max-width: 98vw !important;
        width: 98vw !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
        box-sizing: border-box;
      }
    }

    /* 채팅 말풍선 스타일 */
    .chat-bubble {
      display: inline-block;
      padding: 0.5em 1em;
      border-radius: 18px;
      margin: 0.2em 0;
      max-width: 80%;
      word-break: break-all;
      font-size: 1em;
      position: relative;
    }
    .chat-bubble.user {
      background: #e0f7fa;
      color: #222;
      text-align: left;
      margin-left: 1em;
      align-self: flex-start;
    }
    .chat-bubble.mine {
      background: #ffd180;
      color: #222;
      text-align: right;
      margin-right: 1em;
      align-self: flex-end;
    }
    .chat-bubble.system {
      background: #f5f5f5;
      color: #888;
      text-align: center;
      font-style: italic;
      margin: 0.5em auto;
      align-self: center;
    }
    #handArea {
      display: flex;
      background: #eee;
      padding: 10px;
      box-sizing: border-box;
      margin: 0 auto 10px auto;
      overflow: visible;
    }
    @media (max-width: 900px) {
      #mainWrap { flex-direction: column; justify-content: center; }
      #chatWrap { margin-right: 0; margin-left: 0; max-width: 100%; min-width: 0; }
      #gameArea { max-width: 90vw; min-width: 0; }
    }
  </style>
</head>
<body>
  <div id="mainWrap">
    <div id="gameArea">
      <div style="text-align:right; margin-bottom: 0.5em;">
        <button id="helpBtn" style="padding:0.5em 1.2em;font-size:1em;background:#8bc34a;color:white;border:none;border-radius:8px;cursor:pointer;margin-right:0.5em;">게임룰</button>
        <button id="leaveGameBtn" style="padding:0.5em 1.2em;font-size:1em;background:#e57373;color:white;border:none;border-radius:8px;cursor:pointer;">게임 나가기</button>
      </div>
      <h1 style="text-align:center;margin-bottom:2em;">달무티 게임</h1>
      <div id="gameContent"></div>
    </div>
    <div id="chatWrap">
      <div id="chatMessages"></div>
      <div id="chatInputWrap">
        <input type="text" id="chatInput" placeholder="메시지 입력..." autocomplete="off" />
        <button id="chatSend">전송</button>
      </div>
    </div>
  </div>
  <div id="helpModal" style="display:none;position:fixed;z-index:1000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.35);justify-content:center;align-items:center;">
    <div style="background:#fff;padding:2em 1.5em 1.5em 1.5em;border-radius:12px;max-width:400px;box-shadow:0 2px 16px rgba(0,0,0,0.18);position:relative;">
      <button id="closeHelp" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:1.3em;cursor:pointer;color:#888;">✕</button>
      <h2 style="margin-top:0;">게임 도움말</h2>
      <ul style="font-size:1em;line-height:1.7;margin-bottom:1em;">
        <li>최소 4명, 최대 8명까지 참가할 수 있습니다.</li>
        <li>계급에 따라 새롭게 자리를 배치한다. </li>
        <li>각 계급은 자신보다 낮은 계급에게 이것저것 시킬 수 있다. 거부권은 없다.</li>
        <li>농노는 왕에게 자신의 카드들 중 적힌 수가 가장 작은 카드 2장을 왕에게 조공으로 바친다. 물론 공손하게.</li>
        <li>왕은 자신에게 가장 쓸모없을 것 같은 카드 2장을 농노에게 준다.</li>
        <li>광부는 대주교에게 농노와 같은 방식으로 1장을 조공으로 바치고 대주교는 왕과 같은 방식으로 1장을 준다.</li>
        <li>왕부터 시계방향으로 돌아가면서 카드를 내는데 규칙이 있다.</li>
        <li>맨 처음 플레이어가 낸 카드의 개수만큼만 낼 수 있다.</li>  
        <li>바로 전 플레이어가 낸 카드에 적혀있는 수보다 낮은 수의 카드만 낼 수 있다.</li>
        <li>만약 카드를 낼 수 없다면 패스를 선언한다.</li>
        <li>패스가 계속 선언되어서 한바퀴가 돌아서 맨 마지막 카드를 낸 플레이어의 차례가 되면 그 플래이어가 선으로 새로운 라운드를 시작한다.</li>
        <li>위의 과정을 반복해서 카드를 맨 처음 다 털어버리는 순서로 점수가 부여된다</li>
        <li>다음 게임은 전 게임의 순위로 신분이 배정된다.</li>
        <li>최초 카드 배분시 조커 2장 보유시 혁명 여부 선택가능</li>
        <li>혁명 시 카드교환 단계 생략</li>
        <li>재밌게 즐기셨으면 커피 한잔 사주기</li>
      </ul>
      <div style="font-size:0.95em;color:#888;">팁: <b>!타이머on</b> / <b>!타이머off</b>를 채팅에 입력해 타이머를 제어할 수 있습니다.<br><b>!타이머 20</b> / <b>!타이머 60</b>으로 타이머 시간을 조정할 수 있습니다.<br><b>!스코어</b>를 입력하면 누적 점수를 확인할 수 있습니다.</div>
    </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    console.log('game.html loaded');
    document.addEventListener('DOMContentLoaded', function() {
      // 쿼리스트링에서 roomId, nickname 추출
      function getQueryParam(name) {
        const url = new URL(window.location.href);
        return url.searchParams.get(name);
      }
      const roomId = getQueryParam('roomId');
      const nickname = getQueryParam('nickname');
      if (!roomId || !nickname) {
        alert('잘못된 접근입니다.');
        window.location.href = '/room-list.html';
        return;
      }
      const socket = io();
      socket.on('connect', () => {
        console.log('socket connected! id:', socket.id);
      });
      socket.emit('join', { roomId, nickname }, (res) => {
        if (!res.success && res.message !== '중복 닉네임') {
          alert(res.message);
          window.location.href = '/room-list.html';
        }
      });

      // 게임 상태 변수
      let myCards = [];
      let selected = [];
      let myIdx = null;
      let turnInfo = null;
      let field = null;
      let ordered = [];
      let isCardSelectionMode = false; // 카드 선택 모드 플래그
      console.log('roleAssigned:', ordered);

      let turnCountdown = null;
      let turnEndTime = null;
      let timerEnabled = true; // 서버에서 타이머 상태를 받으면 갱신됨
      let turnTimeSeconds = 30; // 기본 30초

      function startTurnCountdown() {
        if (!timerEnabled || !turnEndTime) {
          if (turnCountdown) {
            clearInterval(turnCountdown);
            turnCountdown = null;
          }
          updateTurnTimerUI();
          return;
        }
        clearInterval(turnCountdown);
        updateTurnTimerUI();
        turnCountdown = setInterval(() => {
          updateTurnTimerUI();
          if (getTurnTimeLeft() <= 0) {
            clearInterval(turnCountdown);
          }
        }, 1000);
      }

      function getTurnTimeLeft() {
        if (!turnEndTime) return 0;
        const timeLeft = Math.max(0, Math.floor((turnEndTime - Date.now()) / 1000));
        return timeLeft;
      }

      function updateTurnTimerUI() {
        const timerDiv = document.getElementById('turnTimer');
        if (timerDiv && timerEnabled && turnInfo && turnInfo.currentPlayer && turnEndTime) {
          const left = getTurnTimeLeft();
          timerDiv.textContent = `⏰ 남은 시간: ${left}초 (${turnTimeSeconds}초 설정)`;
        } else if (timerDiv) {
          timerDiv.textContent = '';
        }
      }

      // 게임 화면 전체를 다시 그리는 함수
      function renderGame() {
        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '';

        // 1. 원탁 그리기
        if (ordered && ordered.length > 0) {
          const n = ordered.length;
          // 화면 크기에 따라 원탁 크기 조정
          const isMobile = window.innerWidth <= 768;
          const isSmallMobile = window.innerWidth <= 480;
          const tableSize = isSmallMobile ? 250 : isMobile ? 300 : 400;
          const radius = tableSize / 2;
          const playerCardWidth = isSmallMobile ? 70 : isMobile ? 80 : 120;
          const playerCardHeight = isSmallMobile ? 50 : isMobile ? 60 : 80;
          
          html += `<div class="table-circle" style="position:relative;width:${tableSize}px;height:${tableSize}px;margin:0 auto;background:#f5f5dc;border-radius:50%;box-shadow:0 2px 12px rgba(0,0,0,0.08);margin-bottom: 1em;">`;
          ordered.forEach((p, i) => {
            const angle = (2 * Math.PI * i) / n - Math.PI / 2;
            const x = tableSize/2 + radius * Math.cos(angle) - playerCardWidth/2;
            const y = tableSize/2 + radius * Math.sin(angle) - playerCardHeight/2;
            const isMyTurn = turnInfo && turnInfo.currentPlayer && turnInfo.currentPlayer.id === p.id;
            const amI = p.id === socket.id;
            const isFinished = p.finished;
            let borderColor = 'transparent';
            let backgroundColor = 'white';
            if (amI) borderColor = '#ff9800';
            if (isMyTurn) backgroundColor = '#adf0b1';
            if (isFinished) {
              backgroundColor = '#e0e0e0';
              borderColor = '#9e9e9e';
            }

            html += `<div class="player-card" style="position:absolute;left:${x}px;top:${y}px;width:${playerCardWidth}px;height:${playerCardHeight}px;text-align:center;background:${backgroundColor};border-radius:12px;box-shadow:0 1px 6px rgba(0,0,0,0.08);padding:0.5em 0.2em;display:flex;flex-direction:column;justify-content:center;align-items:center;border: 3px solid ${borderColor}; transition: all 0.3s;">
              <div style='font-weight:bold;font-size:1.1em;'>${p.role}</div>
              <div style='margin:0.2em 0;'>${p.nickname}</div>
              <div style='font-size:0.9em;color:#666;'>${isFinished ? '🏁 완주!' : `카드 ${p.cardCount || 0}장`}</div>
            </div>`;
          });
          // 필드(이전에 낸 카드)를 테이블 중앙에 노출
          html += '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:1.3em;font-weight:bold;text-align:center;">';
          if (field && field.number) {
            html += '<div style="margin-top:0.7em;font-size:1.1em;text-align:center;">';
            html += '<div style="margin-bottom:0.5em;font-weight:bold;">필드</div>';
            html += '<div style="display:flex;justify-content:center;">';
            if (field.cards && Array.isArray(field.cards)) {
              field.cards.forEach((card, i) => {
                html += `<div style="overflow:visible;width:20px;flex-grow:1;${i === field.cards.length - 1 ? 'width:80px;flex-grow:0;' : ''}">`;
                html += `<div style="width:80px;height:130px;background:#fffbe6;border:4px solid #bdb76b;box-shadow:-3px 0px 8px rgba(0,0,0,0.4);box-sizing:border-box;position:relative;border-radius:6px;">`;
                html += `<div style="position:absolute;top:3px;left:3px;font-size:1em;font-weight:bold;">${card === 'J' ? '🃏' : card}</div>`;
                html += '</div>';
                html += '</div>';
              });
            } else {
              for (let i = 0; i < field.count; i++) {
                html += `<div style="overflow:visible;width:20px;flex-grow:1;${i === field.count - 1 ? 'width:80px;flex-grow:0;' : ''}">`;
                html += `<div style="width:80px;height:130px;background:#fffbe6;border:4px solid #bdb76b;box-shadow:-3px 0px 8px rgba(0,0,0,0.4);box-sizing:border-box;position:relative;border-radius:6px;">`;
                html += `<div style="position:absolute;top:3px;left:3px;font-size:1em;font-weight:bold;">${field.number === 'J' ? '🃏' : field.number}</div>`;
                html += '</div>';
                html += '</div>';
              }
            }
            html += '</div>';
            html += `<div style="margin-top:0.5em;font-size:0.9em;color:#666;"><b>필드:</b> 숫자 ${field.number} (${field.count}장)</div>`;
            html += '</div>';
          }
          html += '</div>';
          html += '</div>';
        }

        // 2. 필드 (이전에 낸 카드)
        // 기존 중앙 표시 코드는 삭제 또는 주석처리
        // if (field && field.number) {
        //   html += '<div style="text-align:center;margin:1em 0;font-size:1.1em">';
        //   html += `<b>필드:</b> 숫자 ${field.number} (${field.count}장)`;
        //   html += '</div>';
        // }

        // 3. 턴 정보
        if (turnInfo && turnInfo.currentPlayer) {
          html += `<div style="text-align:center;margin:3.5em 0 1em 0;font-size:1.2em;">`;
          if (turnInfo.currentPlayer.id === socket.id) {
            html += '<div style="color:#4caf50;font-weight:bold;">🎯 당신의 차례입니다!</div>';
            if (turnInfo.isFirstTurnOfRound) {
              html += '<div style="color:#f57c00;font-weight:bold;margin-top:0.5em;">⚠️ 새로운 라운드의 첫 턴입니다! 패스할 수 없습니다.</div>';
            }
          } else {
            html += `현재 차례: <b>${turnInfo.currentPlayer.nickname}</b> (${turnInfo.currentPlayer.role})`;
            if (turnInfo.isFirstTurnOfRound) {
              html += '<div style="color:#f57c00;font-weight:bold;margin-top:0.5em;">⚠️ 새로운 라운드의 첫 턴입니다!</div>';
            }
          }
          html += '</div>';
          html += '<div id="turnTimer" style="text-align:center;font-size:1.1em;margin-bottom:1em;"></div>';
        }

        // 4. 내 카드
        if (myCards && myCards.length > 0) {
          html += '<div style="margin-top:1em;border-top:1px solid #ccc;padding-top:1em;">';
          html += '<h2 style="text-align:center;margin:0 0 1em 0;">내 카드</h2>';
          html += '<div id="handArea" style="display:flex;background:#eee;padding:10px;box-sizing:border-box;margin:0 auto 10px auto;overflow:visible;">';
          myCards.forEach((card, i) => {
            const isSelected = selected.includes(i);
            html += `<div class="cardBtn" data-idx="${i}" style="overflow:visible;width:40px;flex-grow:1;${i === myCards.length - 1 ? 'width:100px;flex-grow:0;' : ''}">`;
            html += `<div style="width:100px;height:200px;background:${isSelected ? '#ffe082' : '#fffbe6'};border:5px solid ${isSelected ? '#ff9800' : '#bdb76b'};box-shadow:-5px 0px 10px rgba(0,0,0,0.5);box-sizing:border-box;position:relative;cursor:pointer;transition:all 0.2s;border-radius:8px;">`;
            html += `<div style="position:absolute;top:5px;left:5px;font-size:1.2em;font-weight:bold;">${card === 'J' ? '🃏' : card}</div>`;
            html += '</div>';
            html += '</div>';
          });
          html += '</div>';
          html += '<div style="text-align:center;margin-top:1.5em;">';
          html += '<button id="submitBtn" style="padding:0.7em 2em;font-size:1.1em;margin-right:1em;">제출</button>';
          
          // 마지막 플레이어가 남았는지 확인
          const activePlayers = ordered.filter(p => !p.finished).length;
          const isFirstTurn = turnInfo && turnInfo.isFirstTurnOfRound;
          const isMyTurn = turnInfo && turnInfo.currentPlayer && turnInfo.currentPlayer.id === socket.id;
          
          if (activePlayers > 1 && !(isFirstTurn && isMyTurn)) {
            html += '<button id="passBtn" style="padding:0.7em 2em;font-size:1.1em;">패스</button>';
          } else if (isFirstTurn && isMyTurn) {
            html += '<button id="passBtn" style="padding:0.7em 2em;font-size:1.1em;background:#ffcdd2;color:#c62828;cursor:not-allowed;" disabled>첫 턴 패스 불가</button>';
          } else {
            html += '<button id="passBtn" style="padding:0.7em 2em;font-size:1.1em;background:#ccc;color:#666;cursor:not-allowed;" disabled>패스 불가</button>';
          }
          html += '</div>';
          html += '</div>';
        }

        gameContent.innerHTML = html;

        // 5. 카드에 이벤트 리스너 다시 연결
        if (myCards && myCards.length > 0) {
           // 카드 선택
          document.querySelectorAll('.cardBtn').forEach(btn => {
            btn.onclick = function() {
              const idx = parseInt(this.getAttribute('data-idx'));
              const clickedCard = myCards[idx];

              if (selected.includes(idx)) { // 선택 해제
                selected = selected.filter(i => i !== idx);
              } else { // 새로 선택
                if (selected.length === 0) {
                  selected.push(idx);
                } else {
                  const firstCard = myCards[selected[0]];
                  // 조커는 어떤 카드와도 함께 선택 가능
                  if (clickedCard === 'J' || firstCard === 'J' || clickedCard === firstCard) {
                    selected.push(idx);
                  } else {
                    alert('같은 숫자 또는 조커만 함께 선택할 수 있습니다.');
                  }
                }
              }
              renderGame();
            };
          });
          // 제출 버튼
          document.getElementById('submitBtn').onclick = function() {
            if (turnInfo && turnInfo.currentPlayer.id !== socket.id) {
              alert('아직 내 차례가 아닙니다!');
              return;
            }
            if (selected.length === 0) {
              alert('제출할 카드를 선택하세요.');
              return;
            }
            const cardsToPlay = selected.map(i => myCards[i]);
            socket.emit('playCards', cardsToPlay, (res) => {
              if (res && !res.success) {
                alert(res.message);
              } else {
                // 성공 시 선택 해제
                selected = [];
              }
            });
          };
          // 패스 버튼
          document.getElementById('passBtn').onclick = function() {
            if (turnInfo && turnInfo.currentPlayer.id !== socket.id) {
              alert('아직 내 차례가 아닙니다!');
              return;
            }
            socket.emit('passTurn', (res) => {
              if (res && !res.success) {
                alert(res.message);
              }
            });
          };
        }

        // 타이머 UI 갱신
        updateTurnTimerUI();
      }

      // --- 턴 타이머 UI 동기화 ---
      function syncTurnTimer() {
        if (!timerEnabled || !turnEndTime) {
          if (turnCountdown) {
            clearInterval(turnCountdown);
            turnCountdown = null;
          }
          updateTurnTimerUI();
          return;
        }
        startTurnCountdown();
      }

      socket.on('turnChanged', (data) => {
        turnInfo = data;
        renderGame();
        // turnTimerStart 이벤트에서 타이머가 시작됨
      });
      socket.on('newRound', (data) => {
        turnInfo = data;
        field = null;
        appendChat('🔄 새로운 라운드가 시작됩니다!', false, true);
        // 첫 턴 플레이어에게 특별 메시지
        if (data.currentPlayer && data.currentPlayer.id === socket.id) {
          appendChat('🎯 새로운 라운드의 첫 턴입니다! 패스할 수 없으니 카드를 내주세요.', false, true);
        }
        renderGame();
        // turnTimerStart 이벤트에서 타이머가 시작됨
      });
      socket.on('playResult', (data) => {
        console.log('카드 제출 결과:', data);
        if (data.ordered) ordered = data.ordered; // 최신 ordered로 갱신
        const player = ordered[data.playerIdx];
        const cards = data.cards.map(c => c === 'J' ? '🃏' : c).join(' ');

        // 필드 정보 업데이트
        if (data.lastPlay) {
          field = { ...data.lastPlay };
        }

        // 각 플레이어의 카드 수 업데이트
        if (data.playerHands) {
          ordered.forEach((p, i) => {
            p.cardCount = data.playerHands[i];
          });
        }

        // 내가 낸 카드면 손에서 제거
        if (player.id === socket.id && data.myCards) {
          myCards = data.myCards.slice(); // 서버 상태로 동기화
          selected = [];
        }
        
        // 완주한 플레이어 체크
        if (data.finished[data.playerIdx]) {
          appendChat(`🏁 ${player.nickname}님이 완주했습니다!`, false, true);
        }
        renderGame();
        syncTurnTimer();
      });
      socket.on('turnTimeout', () => {
        appendChat('⏰ 제한시간이 초과되어 자동으로 패스 처리되었습니다.', false, true);
        turnEndTime = null;
        updateTurnTimerUI();
      });

      // 게임 초기 설정 이벤트 핸들러
      socket.on('gameSetup', (data) => {
        console.log('=== gameSetup 이벤트 수신 ===');
        console.log('gameSetup 데이터:', data);
        console.log('현재 카드 선택 모드:', isCardSelectionMode);
        
        // 카드 선택 모드 중이면 gameSetup을 무시
        if (isCardSelectionMode) {
          console.log('카드 선택 모드 중이므로 gameSetup을 무시합니다.');
          return;
        }
        
        console.log('gameSetup 처리 시작');
        ordered = data.ordered;
        myCards = data.myCards.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        turnInfo = data.turnInfo;
        field = data.field;
        myIdx = ordered.findIndex(p => p.id === socket.id);
        selected = [];
        
        renderGame();
        syncTurnTimer(); // 카드 교환 완료 후 첫 턴에 타이머 시작

        // 5초 후에 숫자 정보 지우고 다시 그리기
        setTimeout(() => {
            if(ordered && ordered.length > 0) {
              ordered.forEach(p => delete p.card);
              renderGame();
            }
        }, 5000);
      });

      // 카드 교환 이벤트 핸들러
      socket.on('cardExchange', (data) => {
        console.log('카드 교환 완료:', data);
        appendChat(`🔄 카드 교환 완료`, false, true);
      });

      // 달무티 카드 선택 요청 이벤트
      socket.on('selectCardsForSlave', (data) => {
        console.log('=== selectCardsForSlave 이벤트 수신 ===');
        console.log('이벤트 데이터:', data);
        console.log('현재 소켓 ID:', socket.id);
        console.log('현재 닉네임:', nickname);
        console.log('카드 선택 모드 활성화');
        
        isCardSelectionMode = true;
        myCards = data.hand.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        selected = [];
        
        console.log('정렬된 카드:', myCards);
        
        // 카드 선택 UI 표시
        const gameContent = document.getElementById('gameContent');
        if (gameContent) {
          console.log('gameContent 요소 찾음, UI 생성 시작');
          
          let html = '<div style="text-align:center;margin-bottom:2em;">';
          html += '<h2 style="color:#ff9800;">🎯 농노에게 줄 카드 2장을 선택하세요</h2>';
          html += '<p style="color:#666;margin-bottom:1em;">정확히 2장의 카드를 선택해주세요.</p>';
          html += '</div>';
          
          html += '<div style="margin-top:1em;border-top:1px solid #ccc;padding-top:1em;">';
          html += '<h2 style="text-align:center;margin:0 0 1em 0;">내 카드</h2>';
          html += '<div id="handArea" style="display:flex;background:#eee;padding:10px;box-sizing:border-box;margin:0 auto 10px auto;overflow:visible;">';
          myCards.forEach((card, i) => {
            const isSelected = selected.includes(i);
            html += `<div class="cardBtn" data-idx="${i}" style="overflow:visible;width:40px;flex-grow:1;${i === myCards.length - 1 ? 'width:100px;flex-grow:0;' : ''}">`;
            html += `<div style="width:100px;height:200px;background:${isSelected ? '#ffe082' : '#fffbe6'};border:5px solid ${isSelected ? '#ff9800' : '#bdb76b'};box-shadow:-5px 0px 10px rgba(0,0,0,0.5);box-sizing:border-box;position:relative;cursor:pointer;transition:all 0.2s;border-radius:8px;">`;
            html += `<div style="position:absolute;top:5px;left:5px;font-size:1.2em;font-weight:bold;">${card === 'J' ? '🃏' : card}</div>`;
            html += '</div>';
            html += '</div>';
          });
          html += '</div>';
          html += '<div style="text-align:center;margin-top:1.5em;">';
          html += '<button id="confirmSelectionBtn" style="padding:0.7em 2em;font-size:1.1em;background:#4caf50;color:white;border:none;border-radius:8px;cursor:pointer;">선택 완료</button>';
          html += '</div>';
          html += '</div>';
          
          gameContent.innerHTML = html;
          console.log('카드 선택 UI 생성 완료');
          
          // 카드 선택 이벤트 리스너
          document.querySelectorAll('.cardBtn').forEach(btn => {
            btn.onclick = function() {
              const idx = parseInt(this.getAttribute('data-idx'));
              
              if (selected.includes(idx)) { // 선택 해제
                selected = selected.filter(i => i !== idx);
              } else { // 새로 선택
                if (selected.length < 2) {
                  selected.push(idx);
                } else {
                  alert('최대 2장까지만 선택할 수 있습니다.');
                }
              }
              
              // UI 업데이트
              document.querySelectorAll('.cardBtn').forEach((cardBtn, i) => {
                const cardDiv = cardBtn.querySelector('div');
                const isSelected = selected.includes(i);
                cardDiv.style.background = isSelected ? '#ffe082' : '#fffbe6';
                cardDiv.style.borderColor = isSelected ? '#ff9800' : '#bdb76b';
              });
            };
          });
          
          // 선택 완료 버튼
          document.getElementById('confirmSelectionBtn').onclick = function() {
            if (selected.length !== 2) {
              alert('정확히 2장의 카드를 선택해주세요.');
              return;
            }
            
            const selectedCards = selected.map(i => myCards[i]);
            console.log('선택된 카드:', selectedCards);
            socket.emit('dalmutiCardSelection', selectedCards, (res) => {
              if (res && !res.success) {
                alert(res.message);
              } else {
                isCardSelectionMode = false;
                appendChat('✅ 카드 선택이 완료되었습니다.', false, true);
              }
            });
          };
        } else {
          console.error('gameContent 요소를 찾을 수 없습니다!');
        }
      });

      // 대주교 카드 선택 요청 이벤트
      socket.on('selectCardsForMiner', (data) => {
        console.log('=== selectCardsForMiner 이벤트 수신 ===');
        console.log('이벤트 데이터:', data);
        console.log('현재 소켓 ID:', socket.id);
        console.log('현재 닉네임:', nickname);
        console.log('카드 선택 모드 활성화');
        
        isCardSelectionMode = true;
        myCards = data.hand.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        selected = [];
        
        console.log('정렬된 카드:', myCards);
        
        // 카드 선택 UI 표시
        const gameContent = document.getElementById('gameContent');
        if (gameContent) {
          console.log('gameContent 요소 찾음, UI 생성 시작');
          
          let html = '<div style="text-align:center;margin-bottom:2em;">';
          html += '<h2 style="color:#ff9800;">🎯 광부에게 줄 카드 1장을 선택하세요</h2>';
          html += '<p style="color:#666;margin-bottom:1em;">정확히 1장의 카드를 선택해주세요.</p>';
          html += '</div>';
          
          html += '<div style="margin-top:1em;border-top:1px solid #ccc;padding-top:1em;">';
          html += '<h2 style="text-align:center;margin:0 0 1em 0;">내 카드</h2>';
          html += '<div id="handArea" style="display:flex;background:#eee;padding:10px;box-sizing:border-box;margin:0 auto 10px auto;overflow:visible;">';
          myCards.forEach((card, i) => {
            const isSelected = selected.includes(i);
            html += `<div class="cardBtn" data-idx="${i}" style="overflow:visible;width:40px;flex-grow:1;${i === myCards.length - 1 ? 'width:100px;flex-grow:0;' : ''}">`;
            html += `<div style="width:100px;height:200px;background:${isSelected ? '#ffe082' : '#fffbe6'};border:5px solid ${isSelected ? '#ff9800' : '#bdb76b'};box-shadow:-5px 0px 10px rgba(0,0,0,0.5);box-sizing:border-box;position:relative;cursor:pointer;transition:all 0.2s;border-radius:8px;">`;
            html += `<div style="position:absolute;top:5px;left:5px;font-size:1.2em;font-weight:bold;">${card === 'J' ? '🃏' : card}</div>`;
            html += '</div>';
            html += '</div>';
          });
          html += '</div>';
          html += '<div style="text-align:center;margin-top:1.5em;">';
          html += '<button id="confirmSelectionBtn" style="padding:0.7em 2em;font-size:1.1em;background:#4caf50;color:white;border:none;border-radius:8px;cursor:pointer;">선택 완료</button>';
          html += '</div>';
          html += '</div>';
          
          gameContent.innerHTML = html;
          console.log('카드 선택 UI 생성 완료');
          
          // 카드 선택 이벤트 리스너
          document.querySelectorAll('.cardBtn').forEach(btn => {
            btn.onclick = function() {
              const idx = parseInt(this.getAttribute('data-idx'));
              
              if (selected.includes(idx)) { // 선택 해제
                selected = selected.filter(i => i !== idx);
              } else { // 새로 선택
                if (selected.length < 1) {
                  selected.push(idx);
                } else {
                  alert('최대 1장까지만 선택할 수 있습니다.');
                }
              }
              
              // UI 업데이트
              document.querySelectorAll('.cardBtn').forEach((cardBtn, i) => {
                const cardDiv = cardBtn.querySelector('div');
                const isSelected = selected.includes(i);
                cardDiv.style.background = isSelected ? '#ffe082' : '#fffbe6';
                cardDiv.style.borderColor = isSelected ? '#ff9800' : '#bdb76b';
              });
            };
          });
          
          // 선택 완료 버튼
          document.getElementById('confirmSelectionBtn').onclick = function() {
            if (selected.length !== 1) {
              alert('정확히 1장의 카드를 선택해주세요.');
              return;
            }
            
            const selectedCards = selected.map(i => myCards[i]);
            console.log('선택된 카드:', selectedCards);
            socket.emit('archbishopCardSelection', selectedCards, (res) => {
              if (res && !res.success) {
                alert(res.message);
              } else {
                isCardSelectionMode = false;
                appendChat('✅ 카드 선택이 완료되었습니다.', false, true);
              }
            });
          };
        } else {
          console.error('gameContent 요소를 찾을 수 없습니다!');
        }
      });

      // 달무티 카드 선택 대기 이벤트
      socket.on('waitingForDalmuti', (data) => {
        console.log('=== waitingForDalmuti 이벤트 수신 ===');
        console.log('대기 메시지:', data);
        console.log('현재 소켓 ID:', socket.id);
        console.log('현재 닉네임:', nickname);
        
        appendChat(`⏳ ${data.message}`, false, true);
        
        // 대기 화면 표시
        const gameContent = document.getElementById('gameContent');
        if (gameContent) {
          console.log('대기 화면 UI 생성 시작');
          let html = '<div style="text-align:center;margin:2em 0;">';
          html += '<h2 style="color:#666;">⏳ 카드 교환 대기 중...</h2>';
          html += `<p style="color:#888;">${data.message}</p>`;
          html += '<div style="margin-top:2em;font-size:2em;">🔄</div>';
          html += '</div>';
          gameContent.innerHTML = html;
          console.log('대기 화면 UI 생성 완료');
        } else {
          console.error('gameContent 요소를 찾을 수 없습니다!');
        }
      });

      // 카드 교환 대기 이벤트 (달무티와 대주교 모두)
      socket.on('waitingForCardExchange', (data) => {
        console.log('=== waitingForCardExchange 이벤트 수신 ===');
        console.log('대기 메시지:', data);
        console.log('현재 소켓 ID:', socket.id);
        console.log('현재 닉네임:', nickname);
        
        appendChat(`⏳ ${data.message}`, false, true);
        
        // 대기 화면 표시
        const gameContent = document.getElementById('gameContent');
        if (gameContent) {
          console.log('대기 화면 UI 생성 시작');
          let html = '<div style="text-align:center;margin:2em 0;">';
          html += '<h2 style="color:#666;">⏳ 카드 교환 대기 중...</h2>';
          html += `<p style="color:#888;">${data.message}</p>`;
          html += '<div style="margin-top:2em;font-size:2em;">🔄</div>';
          html += '</div>';
          gameContent.innerHTML = html;
          console.log('대기 화면 UI 생성 완료');
        } else {
          console.error('gameContent 요소를 찾을 수 없습니다!');
        }
      });

      // 신분 및 자리 배정 결과 (다음 라운드용)
      socket.on('roleAssigned', (newOrdered) => {
        console.log('roleAssigned for next round:', newOrdered);
        ordered = newOrdered;
        myIdx = ordered.findIndex(p => p.id === socket.id);
        // 다음 라운드를 위해 다른 상태 초기화
        myCards = [];
        selected = [];
        turnInfo = null;
        field = null;
        renderGame();
      });

      // 내 카드 표시 (다음 라운드용)
      socket.on('dealCards', (cards) => {
        myCards = cards.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        selected = [];
        renderGame();
      });

      // 게임 시작 알림 (다음 라운드용)
      socket.on('gameStarted', (data) => {
        console.log('Game started for next round:', data);
        turnInfo = data;
        renderGame();
      });

      // 차례 변경 알림
      socket.on('turnChanged', (data) => {
        console.log('차례 변경:', data);
        turnInfo = data;
        renderGame();
        syncTurnTimer();
      });

      // 카드 제출 결과
      socket.on('playResult', (data) => {
        console.log('카드 제출 결과:', data);
        const player = ordered[data.playerIdx];
        const cards = data.cards.map(c => c === 'J' ? '🃏' : c).join(' ');

        // 필드 정보 업데이트
        if (data.lastPlay) {
          field = { ...data.lastPlay };
        }

        // 각 플레이어의 카드 수 업데이트
        if (data.playerHands) {
          ordered.forEach((p, i) => {
            p.cardCount = data.playerHands[i];
          });
        }

        // 내가 낸 카드면 손에서 제거
        if (player.id === socket.id && data.myCards) {
          myCards = data.myCards.slice(); // 서버 상태로 동기화
          selected = [];
        }
        
        // 완주한 플레이어 체크
        if (data.finished[data.playerIdx]) {
          appendChat(`🏁 ${player.nickname}님이 완주했습니다!`, false, true);
        }
        renderGame();
        syncTurnTimer();
      });

      // 패스 결과
      socket.on('passResult', (data) => {
        console.log('패스 결과:', data);
        const player = ordered[data.playerIdx];
        appendChat(`⏭️ ${player.nickname}님이 패스했습니다. (${data.passes}번째 패스)`, false, true);
      });

      // 새로운 라운드 시작
      socket.on('newRound', (data) => {
        console.log('새 라운드:', data);
        turnInfo = data;
        field = null; // 필드 초기화
        appendChat('🔄 새로운 라운드가 시작됩니다!', false, true);
        renderGame();
        syncTurnTimer();
      });

      // 게임 중단
      socket.on('gameInterrupted', (data) => {
        console.log('게임 중단:', data);

        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '<h1 style="text-align:center;color:#f44336;">⚠️ 게임 중단</h1>';
        html += '<div style="text-align:center;margin-bottom:2em;">';
        html += '<h2>게임이 중단되었습니다</h2>';
        html += `<p style="color:#666;font-size:1.1em;">${data.message}</p>`;
        html += '<p style="color:#888;">플레이어가 부족하여 게임을 계속할 수 없습니다.</p>';
        html += '<p style="color:#f57c00;font-weight:bold;margin-top:1em;">💡 상단의 "게임 나가기" 버튼을 클릭하여 로비로 돌아가주세요.</p>';
        html += '</div>';
        gameContent.innerHTML = html;

        appendChat('⚠️ 게임이 중단되었습니다. 상단의 게임 나가기 버튼을 클릭하여 로비로 돌아가주세요.', false, true);
      });

      // 게임 종료 및 점수
      socket.on('gameEnd', (result) => {
        console.log('게임 종료:', result);

        // 게임 상태 변수들 초기화
        myCards = [];
        selected = [];
        myIdx = null;
        turnInfo = null;
        field = null;
        ordered = [];
        isCardSelectionMode = false;

        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '<h1 style="text-align:center;">게임 종료!</h1>';
        html += '<div style="text-align:center;margin-bottom:2em;">';
        html += '<h2>🏆 완주 순서</h2>';
        result.forEach((player, i) => {
          const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : '🏅';
          html += `<div style="margin:0.5em 0;font-size:1.1em;">`;
          html += `${medal} ${i + 1}위: ${player.nickname} (${player.role}) - ${player.score}점 (총점: ${player.total}점)`;
          html += '</div>';
        });
        html += '</div>';
        html += '<p style="text-align:center;">잠시 후 다음 게임을 시작합니다...</p>';
        gameContent.innerHTML = html;

        appendChat('🎉 게임이 종료되었습니다!', false, true);
      });

      // 최종 결과 (5판 완료)
      socket.on('finalResult', (result) => {
        console.log('최종 결과:', result);

        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '<h1 style="text-align:center;">🎊 최종 결과 🎊</h1>';
        html += '<div style="text-align:center;margin-bottom:2em;">';
        html += '<h2>🏆 최종 우승자</h2>';
        result.forEach((player, i) => {
          const medal = i === 0 ? '👑' : i === 1 ? '🥈' : i === 2 ? '🥉' : '🏅';
          html += `<div style="margin:0.5em 0;font-size:1.1em;">`;
          html += `${medal} ${i + 1}위: ${player.nickname} - ${player.score}점`;
          html += '</div>';
        });
        html += '</div>';
        html += '<div style="text-align:center;">';
        html += '<button onclick="window.location.href=\'/lobby.html\'" style="padding:1em 2em;font-size:1.2em;background:#4caf50;color:white;border:none;border-radius:8px;cursor:pointer;">로비로 돌아가기</button>';
        html += '</div>';

        gameContent.innerHTML = html;

        appendChat('🎊 5판 완료! 최종 결과입니다!', false, true);
      });

      // 채팅 기능
      const chatMessages = document.getElementById('chatMessages');
      const chatInput = document.getElementById('chatInput');
      const chatSend = document.getElementById('chatSend');
      function appendChat(msg, isMine, isSystem) {
        const div = document.createElement('div');
        div.className = 'chat-bubble' + (isSystem ? ' system' : isMine ? ' mine' : ' user');
        div.textContent = msg;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      chatSend.onclick = sendChat;
      chatInput.onkeydown = function(e) { if (e.key === 'Enter') sendChat(); };
      
      function sendChat() {
        const msg = chatInput.value.trim();
        if (!msg) return;
        socket.emit('chat', msg); // 서버로 메시지 전송만 함
        chatInput.value = '';
      }

      socket.on('chat', (data) => {
        // 서버로부터 받은 메시지를 화면에 표시
        if (typeof data === 'object' && data.nickname && data.msg) {
            const isMine = data.nickname === nickname;
            // 시스템 메시지 아님
            appendChat(`${isMine ? '나' : data.nickname}: ${data.msg}`, isMine, false);
        }
      });

      // --- 게임 나가기 버튼 이벤트 ---
      const leaveBtn = document.getElementById('leaveGameBtn');
      if (leaveBtn) {
        leaveBtn.addEventListener('click', function() {
          if (confirm('정말 게임을 나가시겠습니까?')) {
            console.log('게임 나가기 버튼 클릭됨');
            socket.emit('leaveGame');
            // 버튼 비활성화하여 중복 클릭 방지
            leaveBtn.disabled = true;
            leaveBtn.textContent = '나가는 중...';
            leaveBtn.style.background = '#ccc';
          }
        });
      }
      // --- resetClient 이벤트 처리 ---
      socket.on('resetClient', () => {
        localStorage.clear();
        sessionStorage.clear();
        window.location.href = '/index.html';
      });

      socket.on('timerStatus', (data) => {
        console.log('[timerStatus] 이벤트 수신:', data, '-> timerEnabled:', data.enabled);
        timerEnabled = data.enabled;
        updateTurnTimerUI();
      });

      socket.on('timerTimeChanged', (data) => {
        console.log('[timerTimeChanged] 이벤트 수신:', data);
        turnTimeSeconds = data.time;
        // 타이머 시간이 변경되었을 때 UI 업데이트
        updateTurnTimerUI();
      });

      // 도움말 버튼/모달
      document.getElementById('helpBtn').onclick = function() {
        document.getElementById('helpModal').style.display = 'flex';
        // 채팅창 숨기기
        document.getElementById('chatWrap').style.display = 'none';
        // body 스크롤 막기
        document.body.style.overflow = 'hidden';
      };
      document.getElementById('closeHelp').onclick = function() {
        document.getElementById('helpModal').style.display = 'none';
        // 채팅창 다시 보이기
        document.getElementById('chatWrap').style.display = '';
        // body 스크롤 다시 허용
        document.body.style.overflow = '';
      };

      socket.on('turnTimerStart', (data) => {
        // 서버에서 전송된 시작 시간과 종료 시간을 사용
        if (data.startTime && data.endTime) {
          const serverStartTime = data.startTime;
          const now = Date.now();
          
          // 네트워크 지연을 보정하여 정확한 종료 시간 계산
          const networkDelay = now - serverStartTime;
          const correctedEndTime = data.endTime + networkDelay;
          
          turnEndTime = correctedEndTime;
          turnTimeSeconds = data.turnTime || 30;
          
          console.log(`타이머 동기화: 서버시작=${serverStartTime}, 현재=${now}, 지연=${networkDelay}ms, 보정된종료시간=${correctedEndTime}`);
        } else {
          // fallback
          turnEndTime = data.endTime;
          turnTimeSeconds = data.turnTime || 30;
        }
        startTurnCountdown();
      });

      // 혁명 선택 요청 이벤트
      socket.on('revolutionChoice', (data) => {
        console.log('=== revolutionChoice 이벤트 수신 ===', data);
        isCardSelectionMode = true;
        // 혁명 선택 모달 생성
        const gameContent = document.getElementById('gameContent');
        if (gameContent) {
          let html = '<div style="text-align:center;margin:2em 0;">';
          if (data && data.role && data.nickname) {
            html += `<div style=\"font-size:1.1em;color:#333;margin-bottom:1em;\">당신은 <b>${data.role}</b> (${data.nickname}) 입니다.</div>`;
          }
          html += '<h2 style="color:#d32f2f;">🃏🃏 혁명 기회!</h2>';
          html += '<p style="color:#444;font-size:1.1em;margin-bottom:2em;">조커 2장을 보유하셨습니다.<br>혁명을 선언하면 카드 교환 없이 바로 게임이 시작됩니다.<br>혁명을 선언하시겠습니까?</p>';
          html += '<button id="revolutionYesBtn" style="padding:0.8em 2em;font-size:1.1em;background:#d32f2f;color:white;border:none;border-radius:8px;cursor:pointer;margin-right:1em;">혁명 선언</button>';
          html += '<button id="revolutionNoBtn" style="padding:0.8em 2em;font-size:1.1em;background:#888;color:white;border:none;border-radius:8px;cursor:pointer;">혁명 안함</button>';
          html += '</div>';
          gameContent.innerHTML = html;
          document.getElementById('revolutionYesBtn').onclick = function() {
            socket.emit('revolutionResult', { revolution: true });
            isCardSelectionMode = false;
            gameContent.innerHTML = '<div style="text-align:center;margin:2em 0;"><h2 style="color:#d32f2f;">혁명 선언!</h2><p style="color:#444;">카드 교환 없이 게임이 곧 시작됩니다...</p></div>';
          };
          document.getElementById('revolutionNoBtn').onclick = function() {
            socket.emit('revolutionResult', { revolution: false });
            isCardSelectionMode = false;
            gameContent.innerHTML = '<div style="text-align:center;margin:2em 0;"><h2 style="color:#888;">혁명 안함</h2><p style="color:#444;">카드 교환 단계로 진행합니다...</p></div>';
          };
        }
      });



      // 게임 시작 알림 (모든 라운드)
      socket.on('gameStart', (data) => {
        // 만약 현재 페이지가 game.html이 아니면 이동
        if (!window.location.pathname.endsWith('game.html')) {
          // roomId, nickname 쿼리스트링 유지
          const params = new URLSearchParams(window.location.search);
          window.location.href = '/game.html?' + params.toString();
        } else {
          // 혁명 선택이나 카드 교환이 필요한 경우 게임 화면을 렌더링하지 않음
          if (data && (data.needRevolutionChoice || data.needCardExchange)) {
            console.log('혁명 선택 또는 카드 교환이 필요하므로 게임 화면 렌더링을 건너뜁니다.');
            return;
          }
          // 이미 game.html이면 새로고침 또는 render
          renderGame();
        }
      });
    });
  </script>
</body>
</html> 