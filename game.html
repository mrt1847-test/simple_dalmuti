<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>달무티 게임</title>
  <style>
    body { display: flex; justify-content: center; align-items: center; height: 100vh; background: #f5f5dc; }
    #mainWrap { display: flex; flex-direction: row; justify-content: center; align-items: flex-start; }
    #gameArea { min-width: 420px; }
    #chatWrap { width: 260px; margin-left: 2em; background: #fff; border-radius: 10px; box-shadow: 0 1px 8px rgba(0,0,0,0.08); display: flex; flex-direction: column; height: 540px; }
    #chatMessages { flex: 1; overflow-y: auto; padding: 1em; font-size: 1em; }
    #chatInputWrap { display: flex; border-top: 1px solid #eee; }
    #chatInput { flex: 1 1 auto; min-width: 0; border: none; padding: 0.7em; font-size: 1em; border-radius: 0 0 0 10px; }
    #chatSend { width: 56px; border: none; background: #8bc34a; color: #fff; font-size: 1em; border-radius: 0 0 10px 0; cursor: pointer; }
    #chatSend:hover { background: #689f38; }
  </style>
</head>
<body>
  <div id="mainWrap">
    <div id="gameArea">
      <h1 style="text-align:center;">달무티 게임</h1>
      <div id="gameContent"></div>
    </div>
    <div id="chatWrap">
      <div id="chatMessages"></div>
      <div id="chatInputWrap">
        <input type="text" id="chatInput" placeholder="메시지 입력..." autocomplete="off" />
        <button id="chatSend">전송</button>
      </div>
    </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    console.log('game.html loaded');
    document.addEventListener('DOMContentLoaded', function() {
      const nickname = localStorage.getItem('dalmuti_nickname');
      if (!nickname) window.location.href = '/index.html';

      const socket = io("https://simple-dalmuti.onrender.com");
      socket.on('connect', () => {
        console.log('socket connected! id:', socket.id);
      });
      socket.on('roleAssigned', (ordered) => {
        console.log('roleAssigned:', ordered, '내 소켓 id:', socket.id);
      });

      // ★ 서버에 닉네임을 알림
      socket.emit('join', nickname, (res) => {
        if (!res.success && res.message !== '중복 닉네임') {
          alert(res.message);
          window.location.href = '/index.html';
        }
      });

      // 게임 상태 변수
      let myCards = [];
      let selected = [];
      let myIdx = null;
      let turnInfo = null;
      let field = null;
      let ordered = [];
      console.log('roleAssigned:', ordered);

      // 게임 화면 전체를 다시 그리는 함수
      function renderGame() {
        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '';

        // 1. 원탁 그리기
        if (ordered && ordered.length > 0) {
          const n = ordered.length;
          const radius = 160;
          html += '<div style="position:relative;width:400px;height:400px;margin:0 auto;background:#f5f5dc;border-radius:50%;box-shadow:0 2px 12px rgba(0,0,0,0.08);margin-bottom: 2em;">';
          ordered.forEach((p, i) => {
            const angle = (2 * Math.PI * i) / n - Math.PI / 2;
            const x = 200 + radius * Math.cos(angle) - 60;
            const y = 200 + radius * Math.sin(angle) - 40;
            const isMyTurn = turnInfo && turnInfo.currentPlayer && turnInfo.currentPlayer.id === p.id;
            const amI = p.id === socket.id;
            let borderColor = 'transparent';
            if (amI) borderColor = '#ff9800';
            else if (isMyTurn) borderColor = '#4caf50';

            html += `<div style="position:absolute;left:${x}px;top:${y}px;width:120px;height:80px;text-align:center;background:white;border-radius:12px;box-shadow:0 1px 6px rgba(0,0,0,0.08);padding:0.5em 0.2em;display:flex;flex-direction:column;justify-content:center;align-items:center;border: 3px solid ${borderColor}; transition: border-color 0.3s;">
              <div style='font-weight:bold;font-size:1.1em;'>${p.role}</div>
              <div style='margin:0.2em 0;'>${p.nickname}</div>
              <div style='font-size:0.9em;color:#666;'>카드 ${p.cardCount || 0}장</div>
              ${p.card ? `<div style='font-size:0.9em;color:#888;'>숫자: ${p.card}</div>` : ''}
            </div>`;
          });
          // 필드(이전에 낸 카드)를 테이블 중앙에 노출
          html += '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:1.3em;font-weight:bold;text-align:center;">';
          if (field && field.number) {
            html += `<div style=\"margin-top:0.7em;font-size:1.1em;background:#fffbe6;padding:0.5em 1.2em;border-radius:8px;border:1.5px solid #bdb76b;box-shadow:0 1px 4px rgba(0,0,0,0.08);display:inline-block;\">`;
            html += `<b>필드:</b> 숫자 ${field.number} (${field.count}장)`;
            html += '</div>';
          }
          html += '</div>';
          html += '</div>';
        }

        // 2. 필드 (이전에 낸 카드)
        // 기존 중앙 표시 코드는 삭제 또는 주석처리
        // if (field && field.number) {
        //   html += '<div style="text-align:center;margin:1em 0;font-size:1.1em">';
        //   html += `<b>필드:</b> 숫자 ${field.number} (${field.count}장)`;
        //   html += '</div>';
        // }

        // 3. 턴 정보
        if (turnInfo && turnInfo.currentPlayer) {
          html += `<div style="text-align:center;margin-bottom:1em;font-size:1.2em;">`;
          if (turnInfo.currentPlayer.id === socket.id) {
            html += '<div style="color:#4caf50;font-weight:bold;">🎯 당신의 차례입니다!</div>';
          } else {
            html += `현재 차례: <b>${turnInfo.currentPlayer.nickname}</b> (${turnInfo.currentPlayer.role})`;
          }
          html += '</div>';
        }

        // 4. 내 카드
        if (myCards && myCards.length > 0) {
          html += '<div style="margin-top:1em;border-top:1px solid #ccc;padding-top:1em;">';
          html += '<h2 style="text-align:center;margin:0 0 1em 0;">내 카드</h2>';
          html += '<div id="handArea" style="display:flex;max-width:1000px;background:#eee;padding:10px;box-sizing:border-box;margin:0 auto 10px auto;overflow:visible;">';
          myCards.forEach((card, i) => {
            const isSelected = selected.includes(i);
            html += `<div class="cardBtn" data-idx="${i}" style="overflow:visible;width:20px;flex-grow:1;${i === myCards.length - 1 ? 'width:100px;flex-grow:0;' : ''}">`;
            html += `<div style="width:100px;height:200px;background:${isSelected ? '#ffe082' : '#fffbe6'};border:5px solid ${isSelected ? '#ff9800' : '#bdb76b'};box-shadow:-5px 0px 10px rgba(0,0,0,0.5);box-sizing:border-box;position:relative;cursor:pointer;transition:all 0.2s;border-radius:8px;">`;
            html += `<div style="position:absolute;top:5px;left:5px;font-size:1.2em;font-weight:bold;">${card === 'J' ? '🃏' : card}</div>`;
            html += '</div>';
            html += '</div>';
          });
          html += '</div>';
          html += '<div style="text-align:center;margin-top:1.5em;">';
          html += '<button id="submitBtn" style="padding:0.7em 2em;font-size:1.1em;margin-right:1em;">제출</button>';
          
          // 마지막 플레이어가 남았는지 확인
          const activePlayers = ordered.filter(p => !p.finished).length;
          if (activePlayers > 1) {
            html += '<button id="passBtn" style="padding:0.7em 2em;font-size:1.1em;">패스</button>';
          } else {
            html += '<button id="passBtn" style="padding:0.7em 2em;font-size:1.1em;background:#ccc;color:#666;cursor:not-allowed;" disabled>패스 불가</button>';
          }
          html += '</div>';
          html += '</div>';
        }

        gameContent.innerHTML = html;

        // 5. 카드에 이벤트 리스너 다시 연결
        if (myCards && myCards.length > 0) {
           // 카드 선택
          document.querySelectorAll('.cardBtn').forEach(btn => {
            btn.onclick = function() {
              const idx = parseInt(this.getAttribute('data-idx'));
              const clickedCard = myCards[idx];

              if (selected.includes(idx)) { // 선택 해제
                selected = selected.filter(i => i !== idx);
              } else { // 새로 선택
                if (selected.length === 0) {
                  selected.push(idx);
                } else {
                  const firstCard = myCards[selected[0]];
                  // 조커는 어떤 카드와도 함께 선택 가능
                  if (clickedCard === 'J' || firstCard === 'J' || clickedCard === firstCard) {
                    selected.push(idx);
                  } else {
                    alert('같은 숫자 또는 조커만 함께 선택할 수 있습니다.');
                  }
                }
              }
              renderGame();
            };
          });
          // 제출 버튼
          document.getElementById('submitBtn').onclick = function() {
            if (turnInfo && turnInfo.currentPlayer.id !== socket.id) {
              alert('아직 내 차례가 아닙니다!');
              return;
            }
            if (selected.length === 0) {
              alert('제출할 카드를 선택하세요.');
              return;
            }
            const cardsToPlay = selected.map(i => myCards[i]);
            socket.emit('playCards', cardsToPlay, (res) => {
              if (res && !res.success) {
                alert(res.message);
              } else {
                // 성공 시 선택 해제
                selected = [];
              }
            });
          };
          // 패스 버튼
          document.getElementById('passBtn').onclick = function() {
            if (turnInfo && turnInfo.currentPlayer.id !== socket.id) {
              alert('아직 내 차례가 아닙니다!');
              return;
            }
            socket.emit('passTurn');
          };
        }
      }

      // 게임 초기 설정 이벤트 핸들러
      socket.on('gameSetup', (data) => {
        console.log('Game setup received:', data);
        ordered = data.ordered;
        myCards = data.myCards.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        turnInfo = data.turnInfo;
        field = data.field;
        myIdx = ordered.findIndex(p => p.id === socket.id);
        selected = [];
        
        renderGame();

        // 5초 후에 숫자 정보 지우고 다시 그리기
        setTimeout(() => {
            if(ordered && ordered.length > 0) {
              ordered.forEach(p => delete p.card);
              renderGame();
            }
        }, 5000);
      });

      // 신분 및 자리 배정 결과 (다음 라운드용)
      socket.on('roleAssigned', (newOrdered) => {
        console.log('roleAssigned for next round:', newOrdered);
        ordered = newOrdered;
        myIdx = ordered.findIndex(p => p.id === socket.id);
        // 다음 라운드를 위해 다른 상태 초기화
        myCards = [];
        selected = [];
        turnInfo = null;
        field = null;
        renderGame();
      });

      // 내 카드 표시 (다음 라운드용)
      socket.on('dealCards', (cards) => {
        myCards = cards.sort((a,b) => (a==='J' ? 13 : a) - (b==='J' ? 13 : b));
        selected = [];
        renderGame();
      });

      // 게임 시작 알림 (다음 라운드용)
      socket.on('gameStarted', (data) => {
        console.log('Game started for next round:', data);
        turnInfo = data;
        renderGame();
      });

      // 차례 변경 알림
      socket.on('turnChanged', (data) => {
        console.log('차례 변경:', data);
        turnInfo = data;
        renderGame();
      });

      // 카드 제출 결과
      socket.on('playResult', (data) => {
        console.log('카드 제출 결과:', data);
        const player = ordered[data.playerIdx];
        const cards = data.cards.map(c => c === 'J' ? '🃏' : c).join(' ');

        // 필드 정보 업데이트
        if (data.lastPlay) {
          field = { ...data.lastPlay };
        }

        // 각 플레이어의 카드 수 업데이트
        if (data.playerHands) {
          ordered.forEach((p, i) => {
            p.cardCount = data.playerHands[i];
          });
        }

        // 내가 낸 카드면 손에서 제거
        if (player.id === socket.id) {
          data.cards.forEach(card => {
            const index = myCards.indexOf(card);
            if (index > -1) myCards.splice(index, 1);
          });
        }
        
        // 완주한 플레이어 체크
        if (data.finished[data.playerIdx]) {
          appendChat(`🏁 ${player.nickname}님이 완주했습니다!`, false);
        }

        appendChat(`🎴 ${player.nickname}님이 ${cards}를 냈습니다.`, false);
        renderGame();
      });

      // 패스 결과
      socket.on('passResult', (data) => {
        console.log('패스 결과:', data);
        const player = ordered[data.playerIdx];
        appendChat(`⏭️ ${player.nickname}님이 패스했습니다. (${data.passes}번째 패스)`, false);
      });

      // 새로운 라운드 시작
      socket.on('newRound', (data) => {
        console.log('새 라운드:', data);
        turnInfo = data;
        field = null; // 필드 초기화
        appendChat('🔄 새로운 라운드가 시작됩니다!', false);
        renderGame();
      });

      // 게임 종료 및 점수
      socket.on('gameEnd', (result) => {
        console.log('게임 종료:', result);

        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '<h1 style="text-align:center;">게임 종료!</h1>';
        html += '<div style="text-align:center;margin-bottom:2em;">';
        html += '<h2>🏆 완주 순서</h2>';
        result.forEach((player, i) => {
          const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : '🏅';
          html += `<div style="margin:0.5em 0;font-size:1.1em;">`;
          html += `${medal} ${i + 1}위: ${player.nickname} (${player.role}) - ${player.score}점 (총점: ${player.total}점)`;
          html += '</div>';
        });
        html += '</div>';
        html += '<p style="text-align:center;">잠시 후 다음 게임을 시작합니다...</p>';
        gameContent.innerHTML = html;

        appendChat('🎉 게임이 종료되었습니다!', false);
      });

      // 최종 결과 (5판 완료)
      socket.on('finalResult', (result) => {
        console.log('최종 결과:', result);

        const gameContent = document.getElementById('gameContent');
        if (!gameContent) return;

        let html = '<h1 style="text-align:center;">🎊 최종 결과 🎊</h1>';
        html += '<div style="text-align:center;margin-bottom:2em;">';
        html += '<h2>🏆 최종 우승자</h2>';
        result.forEach((player, i) => {
          const medal = i === 0 ? '👑' : i === 1 ? '🥈' : i === 2 ? '🥉' : '🏅';
          html += `<div style="margin:0.5em 0;font-size:1.1em;">`;
          html += `${medal} ${i + 1}위: ${player.nickname} - ${player.score}점`;
          html += '</div>';
        });
        html += '</div>';
        html += '<div style="text-align:center;">';
        html += '<button onclick="window.location.href=\'/lobby.html\'" style="padding:1em 2em;font-size:1.2em;background:#4caf50;color:white;border:none;border-radius:8px;cursor:pointer;">로비로 돌아가기</button>';
        html += '</div>';

        gameContent.innerHTML = html;

        appendChat('🎊 5판 완료! 최종 결과입니다!', false);
      });

      // 채팅 기능
      const chatMessages = document.getElementById('chatMessages');
      const chatInput = document.getElementById('chatInput');
      const chatSend = document.getElementById('chatSend');
      function appendChat(msg, isMine) {
        const div = document.createElement('div');
        div.textContent = msg;
        div.style.margin = '0.2em 0';
        if (isMine) div.style.textAlign = 'right';
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      chatSend.onclick = sendChat;
      chatInput.onkeydown = function(e) { if (e.key === 'Enter') sendChat(); };
      
      function sendChat() {
        const msg = chatInput.value.trim();
        if (!msg) return;
        socket.emit('chat', msg); // 서버로 메시지 전송만 함
        chatInput.value = '';
      }

      socket.on('chat', (data) => {
        // 서버로부터 받은 메시지를 화면에 표시
        if (typeof data === 'object' && data.nickname && data.msg) {
            const isMine = data.nickname === nickname;
            const prefix = isMine ? '나' : data.nickname;
            appendChat(`${prefix}: ${data.msg}`, isMine);
        }
      });
    });
  </script>
</body>
</html> 